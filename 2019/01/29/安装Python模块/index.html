<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>安装Python模块(官网翻译) | 灵气博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="##安装Python模块（旧版）

作者：   格雷格沃德
也可以看看：
  安装Python模块     最新的模块安装文档
本文档描述了Python Distribution Utilities（“Distutils”）来自最终用户的观点，描述如何通过构建扩展标准Python安装的功能并安装第三方Python模块和扩展。
注意：本指南仅涵盖构建和构建的基本工具  分发作为此版本的一部分提供的扩">
<meta property="og:type" content="article">
<meta property="og:title" content="安装Python模块(官网翻译)">
<meta property="og:url" content="https://python1.cn/2019/01/29/安装Python模块/index.html">
<meta property="og:site_name" content="灵气博客">
<meta property="og:description" content="##安装Python模块（旧版）

作者：   格雷格沃德
也可以看看：
  安装Python模块     最新的模块安装文档
本文档描述了Python Distribution Utilities（“Distutils”）来自最终用户的观点，描述如何通过构建扩展标准Python安装的功能并安装第三方Python模块和扩展。
注意：本指南仅涵盖构建和构建的基本工具  分发作为此版本的一部分提供的扩">
<meta property="og:updated_time" content="2019-01-29T05:46:28.492Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安装Python模块(官网翻译)">
<meta name="twitter:description" content="##安装Python模块（旧版）

作者：   格雷格沃德
也可以看看：
  安装Python模块     最新的模块安装文档
本文档描述了Python Distribution Utilities（“Distutils”）来自最终用户的观点，描述如何通过构建扩展标准Python安装的功能并安装第三方Python模块和扩展。
注意：本指南仅涵盖构建和构建的基本工具  分发作为此版本的一部分提供的扩">
  
    <link rel="alternate" href="/atom.xml" title="灵气博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">灵气博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://python1.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-安装Python模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/29/安装Python模块/" class="article-date">
  <time datetime="2019-01-29T05:46:28.417Z" itemprop="datePublished">2019-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      安装Python模块(官网翻译)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##安装Python模块（旧版）</p>
<hr>
<p>作者：<br>   格雷格沃德</p>
<p>也可以看看：</p>
<p>  安装Python模块<br>     最新的模块安装文档</p>
<p>本文档描述了Python Distribution Utilities<br>（“Distutils”）来自最终用户的观点，描述如何<br>通过构建扩展标准Python安装的功能<br>并安装第三方Python模块和扩展。</p>
<p>注意：本指南仅涵盖构建和构建的基本工具<br>  分发作为此版本的一部分提供的扩展<br>  蟒蛇。第三方工具提供更易于使用和更安全<br>  备择方案。请参阅中的快速建议部分<br>  Python包装用户指南以获取更多信息。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>虽然Python的广泛标准库涵盖了许多编程<br>需要时，通常会有需要添加新内容的时间<br>以第三方的形式安装Python的功能<br>模块。这可能是支持您自己的编程所必需的，或者<br>支持您想要使用的应用程序<br>用Python编写。</p>
<p>在过去，几乎没有人支持添加第三方<br>模块到现有的Python安装。随着介绍<br>Python 2.0中的Python Distribution Utilities（简称Distutils），<br>这改变了。</p>
<p>本文档主要针对需要安装的人员<br>第三方Python模块：最终用户和系统管理员<br>只需要运行一些Python应用程序和现有的Python<br>想要为他们的工具箱添加一些新东西的程序员。您<br>不需要知道Python来阅读这个文档; 会有一些<br>简要介绍如何使用Python的交互模式来探索你的<br>安装，但就是这样。如果您正在寻找有关如何的信息<br>分发您自己的Python模块，以便其他人可以使用它们，请参阅<br>Distributing Python Modules（Legacy version）手册。调试<br>设置脚本也可能是有意义的。</p>
<h2 id="最佳案例：琐碎的安装"><a href="#最佳案例：琐碎的安装" class="headerlink" title="最佳案例：琐碎的安装"></a>最佳案例：琐碎的安装</h2><p>在最好的情况下，有人会准备一个特殊版本的<br>您要安装的模块分发是专门针对的<br>在您的平台上安装，就像您的平台上的任何其他软件一样<br>平台。例如，模块开发人员可能会生成可执行文件<br>适用于Windows用户的安装程序，适用于用户的RPM软件包<br>基于RPM的Linux系统（Red Hat，SuSE，Mandrake等），a<br>适用于基于Debian的Linux系统用户的Debian软件包，等等。</p>
<p>在这种情况下，您可以下载适合您的安装程序<br>平台并用它做显而易见的事情：运行它，如果它是一个<br>可执行安装程序，“rpm –install”它，如果它是RPM，等等<br>不需要运行Python或安装脚本，您不需要编译<br>什么 - 你甚至可能不需要阅读任何指令（尽管如此）<br>无论如何，这总是一个好主意）。</p>
<p>当然，事情并不总是那么容易。你可能是<br>感兴趣的是一个没有易用性的模块分发<br>平台的安装程序。在这种情况下，你必须从头开始<br>模块的作者/维护者发布的源代码分发。<br>从源代码分发安装并不是太难，只要<br>模块以标准方式打包。本文档的大部分内容<br>是关于从标准源构建和安装模块<br>分布。</p>
<h2 id="新标准：Distutils"><a href="#新标准：Distutils" class="headerlink" title="新标准：Distutils"></a>新标准：Distutils</h2><p>如果您下载模块源代码分发，您可以说得很漂亮<br>如果以标准方式包装和分发，即快速<br>使用Distutils。首先，分发的名称和版本号<br>将以下载档案的名义突出显示，<br>例如“foo-1.0.tar.gz”或“widget-0.9.7.zip”。接下来，存档将<br>解压缩到一个命名相似的目录：“foo-1.0”或“widget-0.9.7”。<br>此外，该发行版将包含一个安装脚本“setup.py”，<br>和一个名为“README.txt”或可能只是“README”的文件，应该是<br>解释建立和安装模块分发是一个<br>从终端运行一个命令的简单问题：</p>
<p>   python setup.py安装</p>
<p>对于Windows，应从命令提示符窗口运行此命令<br>（开始‣配件）：</p>
<p>   setup.py安装</p>
<p>如果所有这些都是真的，那么你已经知道如何构建和<br>安装刚刚下载的模块：运行上面的命令。<br>除非您需要以非标准方式安装或自定义<br>在构建过程中，您并不需要本手册。或者更确切地说，<br>以上命令是您完成本手册所需的一切。</p>
<h1 id="标准构建和安装"><a href="#标准构建和安装" class="headerlink" title="标准构建和安装"></a>标准构建和安装</h1><p>如新标准部分所述：Distutils，building and<br>使用Distutils安装模块分发通常是一个<br>从终端运行的简单命令：</p>
<p>   python setup.py安装</p>
<h2 id="平台变化"><a href="#平台变化" class="headerlink" title="平台变化"></a>平台变化</h2><p>您应该始终从分发根运行setup命令<br>目录，即模块源的顶级子目录<br>分发解包。例如，如果您刚刚下载了一个<br>模块源码分发“foo-1.0.tar.gz”到Unix系统上了<br>正常的事情是：</p>
<p>   gunzip -c foo-1.0.tar.gz | tar xf  -  #unpacks到目录foo-1.0<br>   cd foo-1.0<br>   python setup.py安装</p>
<p>在Windows上，您可能会下载“foo-1.0.zip”。如果你下载了<br>存档文件为“C：\ Temp”，然后将解压缩到<br>“C：\ TEMP \ FOO-1.0”; 你可以使用一个存档操纵器<br>图形用户界面（如WinZip）或命令行工具（如<br>作为<strong> unzip </strong>或<strong> pkunzip </strong>）解压缩档案。然后，打开一个<br>命令提示符窗口并运行：</p>
<p>   cd c：\ Temp \ foo-1.0<br>   python setup.py安装</p>
<h2 id="拆分工作"><a href="#拆分工作" class="headerlink" title="拆分工作"></a>拆分工作</h2><p>运行“setup.py install”可在一次运行中构建和安装所有模块。<br>如果你喜欢逐步工作—如果你愿意，特别有用<br>定制构建过程，或者如果出现问题 - 你可以<br>使用安装脚本一次做一件事。这是特别的<br>当构建和安装将由不同的用户完成时有用—<br>例如，您可能希望构建模块分发并交付它<br>关闭系统管理员进行安装（或自己动手，<br>具有超级用户权限）。</p>
<p>例如，您可以一步构建所有内容，然后安装<br>通过两次调用安装脚本，第二步中的所有内容：</p>
<p>   python setup.py构建<br>   python setup.py安装</p>
<p>如果这样做，您会注意到运行<strong> install </strong>命令<br>首先运行<strong> build </strong>命令，在这种情况下—很快<br>注意到它无关，因为“构建”中的所有内容<br>目录是最新的。</p>
<p>如果你所做的一切，你可能不需要这种能力来经常分解<br>安装模块是从网上下载的，但它非常方便<br>更高级的任务。如果您开始分发自己的Python<br>模块和扩展，你将运行许多单独的Distutils<br>命令本身。</p>
<h2 id="建筑如何运作"><a href="#建筑如何运作" class="headerlink" title="建筑如何运作"></a>建筑如何运作</h2><p>如上所述，<strong> build </strong>命令负责放置<br>要安装到<em> build目录中的文件</em>。默认情况下，这是<br>分布根下的“构建”; 如果你过分担心<br>有了速度，或者想保持源树原始，你可以改变<br>使用“–build-base”选项的构建目录。例如：</p>
<p>   python setup.py build –build-base = / path / to / pybuild / foo-1.0</p>
<p>（或者您可以在系统中使用指令永久执行此操作<br>个人Distutils配置文件; 见Distutils部分<br>配置文件。）通常，这不是必需的。</p>
<p>构建树的默认布局如下：</p>
<p>   — build / — lib /<br>   要么<br>   — build / — lib。<plat> /<br>                  温度。&lt;高原&gt; /</plat></p>
<p>其中“<plat>”扩展为当前的简要描述<br>OS /硬件平台和Python版本。第一种形式，只有一个<br>“lib”目录，用于“纯模块分发”—即<br>模块发行版，仅包含纯Python模块。如果一个<br>模块分发包含任何扩展（模块写入<br>C / C ++），然后使用第二种形式，带有两个“<plat>”目录。<br>在这种情况下，“temp。<em> plat </em>”目录包含临时文件<br>由编译/链接进程生成但实际上没有得到的<br>安装。在任何一种情况下，都是“lib”（或“lib。<em> plat </em>”）目录<br>包含所有Python模块（纯Python和扩展）<br>安装。</plat></plat></p>
<p>将来，将添加更多目录来处理Python<br>脚本，文档，二进制可执行文件，以及其他任何东西<br>需要处理安装Python模块的工作<br>应用。</p>
<h2 id="安装如何工作"><a href="#安装如何工作" class="headerlink" title="安装如何工作"></a>安装如何工作</h2><p><strong> build </strong>命令运行后（无论是显式运行还是运行）<br><strong> install </strong>命令为你做的），<strong>安装工作</strong><br>命令相对简单：它所要做的就是复制一切<br>在“build / lib”（或“build / lib。<em> plat </em>”）下到您选择的安装<br>目录。</p>
<p>如果你没有选择安装目录—即，如果你只是运行<br>“setup.py install”—然后<strong> install </strong>命令安装到<br>第三方Python模块的标准位置。这个位置<br>因平台和Python本身的构建/安装方式而异。上<br>Unix（和Mac OS X，也是基于Unix的），它也依赖于<br>是否安装的模块分发是纯Python还是<br>包含扩展名（“非纯”）：</p>
<ul>
<li>——————- + —————————– ————————– + ———————– —————————– + ——— +<br>| 平台| 标准安装位置| 默认值| 备注|</li>
<li>=================== + ============================= ===== + ======================= ============================= + ========= +<br>| Unix（纯）| “<em>前缀</em> / lib / python <em> XY </em> / site-packages”| “/ usr / local / lib / python <em> XY </em> / site-packages”| （1）|</li>
<li>——————- + —————————– ————————– + ———————– —————————– + ——— +<br>| Unix（非纯）| “<em> exec-prefix </em> / lib / python <em> XY </em> / site-packages”| “/ usr / local / lib / python <em> XY </em> / site-packages”| （1）|</li>
<li>——————- + —————————– ————————– + ———————– —————————– + ——— +<br>| Windows | “<em>前缀</em> \ Lib \ site-packages”| “C：\ Python <em> XY </em> \ Lib \ site-packages”| （2）|</li>
<li>——————- + —————————– ————————– + ———————– —————————– + ——— +</li>
</ul>
<p>笔记：</p>
<p>大多数Linux发行版都将Python作为标准的一部分<br>   系统，所以“<em> prefix </em>”和“<em> exec-prefix </em>”通常都是<br>   Linux上的“/ usr”。如果您自己在Linux上构建Python（或任何<br>   类Unix系统），默认为“<em> prefix </em>”和“<em> exec-prefix </em>”<br>   “在/ usr /地方”。</p>
<ol>
<li>Windows上的默认安装目录是“C：\ Program<br>在Python 1.6a1,1.5.2和更早版本下的Files \ Python。</li>
</ol>
<p>“<em> prefix </em>”和“<em> exec-prefix </em>”代表Python的目录<br>安装到，并在运行时找到它的库。他们<br>在Windows下总是一样的，在Unix下经常是一样的<br>和Mac OS X.您可以找到您的Python安装使用的内容<br>通过在交互模式下运行Python，“<em> prefix </em>”和“<em> exec-prefix </em>”<br>并键入一些简单的命令。在Unix下，只需输入“python”即可<br>shell提示符。在Windows下，选择开始‣程序‣PythonXY<br>‣Python（命令行）。解释器启动后，键入<br>提示符下的Python代码。例如，在我的Linux系统上，我输入<br>下面显示了三个Python语句，并获得如图所示的输出，<br>找出我的“<em>前缀</em>”和“<em> exec-prefix </em>”：</p>
<p>   Python 2.4（＃26，2004年8月7日，17：19：02）<br>   输入“帮助”，“版权”，“信用”或“许可”以获取更多信息。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import sys<br>sys.prefix<br>   ‘在/ usr’<br>sys.exec_prefix<br>   ‘在/ usr’</p>
</blockquote>
</blockquote>
</blockquote>
<p>本文档中使用了一些其他占位符：“<em> XY </em>”代表<br>Python的版本，例如“3.2”; “<em> abiflags </em>”将是<br>替换为“sys.abiflags”的值或空字符串<br>没有定义ABI标志的平台; “<em> distname </em>”将被替换<br>通过正在安装的模块分发的名称。点和<br>资本化在路径上很重要; 例如，一个值<br>在UNIX上使用“python3.2”通常会在Windows上使用“Python32”。</p>
<p>如果您不想将模块安装到标准位置，或者如果<br>你没有在那里写的权限，那么你需要阅读<br>备用安装部分中的备用安装。如果你<br>想要更加重视自定义安装目录，请参阅<br>自定义安装上的自定义安装部分</p>
<h1 id="备用安装"><a href="#备用安装" class="headerlink" title="备用安装"></a>备用安装</h1><p>通常，有必要或希望将模块安装到某个位置<br>除了第三方Python模块的标准位置。对于<br>例如，在Unix系统上，您可能没有写入权限<br>标准的第三方模块目录。或者你可能想尝试一下<br>在使模块成为本地Python的标准部分之前将其输出<br>安装。升级分发时尤其如此<br>已存在：您希望确保现有的脚本基础<br>在实际升级之前仍然可以使用新版本。</p>
<p>Distutils <strong> install </strong>命令旨在进行安装<br>模块分布到备用位置简单而无痛。<br>基本的想法是你提供了一个基本目录<br>安装，<strong> install </strong>命令选择一组目录<br>（在此基本目录下称为<em>安装方案</em>）<br>安装文件。各个平台的细节有所不同，请阅读<br>以下哪部分适用于您。</p>
<p>请注意，各种备用安装方案是相互的<br>独家：您可以传递“–user”，或“ -  home”，或“–prefix”和“ -<br>exec-prefix“，或”–install-base“和”–install-platbase“，但是你<br>不能混合这些群体。</p>
<h2 id="备用安装：用户方案"><a href="#备用安装：用户方案" class="headerlink" title="备用安装：用户方案"></a>备用安装：用户方案</h2><p>该方案旨在成为用户最方便的解决方案<br>对全局site-packages目录没有写权限<br>或者不想安装到其中。它启用了一个简单的选项：</p>
<p>   python setup.py install –user</p>
<p>文件将安装到“site.USER_BASE”的子目录中<br>（以下写成“<em> userbase </em>”）。这个方案安装纯Python<br>模块和扩展模块在同一位置（也称为<br>“site.USER_SITE”）。以下是UNIX的值，包括Mac OS X：</p>
<ul>
<li>—————– + ——————————- —————————— +<br>| 文件类型| 安装目录|</li>
<li>================= + =============================== ============================== +<br>| 模块| “<em> userbase </em> / lib / python <em> XY </em> / site-packages”|</li>
<li>—————– + ——————————- —————————— +<br>| 脚本| “<em> userbase </em> / bin”|</li>
<li>—————– + ——————————- —————————— +<br>| 数据| “<em> userbase </em>”|</li>
<li>—————– + ——————————- —————————— +<br>| C头| “<em> userbase </em> / include / python <em> XY ** abiflags </em> / <em> distname </em>”|</li>
<li>—————– + ——————————- —————————— +</li>
</ul>
<p>以下是Windows上使用的值：</p>
<ul>
<li>—————– + ——————————- —————————— +<br>| 文件类型| 安装目录|</li>
<li>================= + =============================== ============================== +<br>| 模块| “<em> userbase </em> \ Python <em> XY </em> \ site-packages”|</li>
<li>—————– + ——————————- —————————— +<br>| 脚本| “<em> userbase </em> \ Python <em> XY </em> \ Scripts”|</li>
<li>—————– + ——————————- —————————— +<br>| 数据| “<em> userbase </em>”|</li>
<li>—————– + ——————————- —————————— +<br>| C头| “<em> userbase </em> \ Python <em> XY </em> \ Include {distname}”|</li>
<li>—————– + ——————————- —————————— +</li>
</ul>
<p>与其他方案相比，使用此方案的优势<br>下面描述的是用户site-packages目录<br>正常条件总是包含在“sys.path”中（有关详细信息，请参阅“站点”）<br>信息），这意味着没有额外的步骤来执行<br>运行“setup.py”脚本以完成安装后。</p>
<p><strong> build_ext </strong>命令还有一个“–user”选项可供添加<br>“<em> userbase </em> / include”到头文件的编译器搜索路径和<br>“<em> userbase </em> / lib”到库的编译器搜索路径以及<br>到共享C库（rpath）的运行时搜索路径。</p>
<h2 id="替代安装：家庭计划"><a href="#替代安装：家庭计划" class="headerlink" title="替代安装：家庭计划"></a>替代安装：家庭计划</h2><p>“家庭计划”背后的想法是你建立和维护一个<br>个人藏匿的Python模块。该方案的名称源自<br>在Unix上使用“home”目录的想法，因为它并不罕见<br>Unix用户使他们的主目录有类似的布局<br>“/ usr /”或“/ usr / local /”。这个方案可以被任何人使用，<br>无论他们安装什么操作系统。</p>
<p>安装新模块分发非常简单</p>
<p>   python setup.py install –home = <dir></dir></p>
<p>在哪里可以为“ -  home”选项提供您喜欢的任何目录。<br>在Unix上，懒惰的打字员只需输入代字号（“〜”）; <strong>安装</strong><br>命令会将其扩展到您的主目录：</p>
<p>   python setup.py install –home =〜</p>
<p>为了让Python找到用这个方案安装的发行版，你<br>可能必须修改Python的搜索路径或编辑“sitecustomize”（参见<br>“site”）调用“site.addsitedir（）”或编辑“sys.path”。</p>
<p>“–home”选项定义安装基目录。档<br>安装到安装基础下的以下目录中<br>如下：</p>
<ul>
<li>—————– + ——————————- —————————— +<br>| 文件类型| 安装目录|</li>
<li>================= + =============================== ============================== +<br>| 模块| “<em> home </em> / lib / python”|</li>
<li>—————– + ——————————- —————————— +<br>| 脚本| “<em> home </em> / bin”|</li>
<li>—————– + ——————————- —————————— +<br>| 数据| “<em> home </em>”|</li>
<li>—————– + ——————————- —————————— +<br>| C头| “<em> home </em> / include / python / <em> distname </em>”|</li>
<li>—————– + ——————————- —————————— +</li>
</ul>
<p>（如果你在Windows上，请用反斜杠替换斜杠。）</p>
<h2 id="备用安装：Unix（前缀方案）"><a href="#备用安装：Unix（前缀方案）" class="headerlink" title="备用安装：Unix（前缀方案）"></a>备用安装：Unix（前缀方案）</h2><p>当您希望使用一个Python时，“前缀方案”很有用<br>安装以执行构建/安装（即运行安装程序）<br>脚本），但将模块安装到第三方模块目录中<br>一个不同的Python安装（或看起来像一个<br>不同的Python安装）。如果这听起来有点不寻常，那就是它<br>是 - 这就是之前用户和家庭计划的原因。但是，那里<br>至少有两种已知的情况，其中前缀方案将是有用的。</p>
<p>首先，考虑许多Linux发行版将Python放在“/ usr”中，<br>而不是更传统的“/ usr / local”。这完全是<br>适当的，因为在那些情况下Python是“系统”的一部分<br>而不是本地插件。但是，如果您正在安装Python<br>来自源代码的模块，您可能希望它们进入<br>“/usr/local/lib/python2.<em>X</em>”而不是“/usr/lib/python2.<em>X</em>”。这个<br>可以完成</p>
<p>   / usr / bin / python setup.py install –prefix = / usr / local</p>
<p>另一种可能性是网络文件系统所用的名称<br>写入远程目录不同于用于读取的名称<br>它：例如，Python解释器访问为<br>“/ usr / local / bin / python”可能会搜索模块<br>“/usr/local/lib/python2.<em>X</em>”，但这些模块必须是<br>安装到，例如“/mnt/<em>@server</em>/export/lib/python2.<em>X</em>”。这个<br>可以完成</p>
<p>   / usr / local / bin / python setup.py install –prefix = / mnt / @ server / export</p>
<p>在任何一种情况下，“ -  prefix”选项都定义了安装基础，<br>并且“–exec-prefix”选项定义特定于平台的<br>安装基础，用于特定于平台的文件。<br>（目前，这仅仅意味着非纯模块分发，但可以<br>扩展到C库，二进制可执行文件等。）如果“–exec-<br>前缀“未提供，默认为”–prefix“。文件是<br>安装如下：</p>
<ul>
<li>——————- + —————————– ——————————- +<br>| 文件类型| 安装目录|</li>
<li>=================== + ============================= =============================== +<br>| Python模块| “<em>前缀</em> / lib / python <em> XY </em> / site-packages”|</li>
<li>——————- + —————————– ——————————- +<br>| 扩展模块| “<em> exec-prefix </em> / lib / python <em> XY </em> / site-packages”|</li>
<li>——————- + —————————– ——————————- +<br>| 脚本| “<em>前缀</em> / bin”|</li>
<li>——————- + —————————– ——————————- +<br>| 数据| “<em>前缀</em>”|</li>
<li>——————- + —————————– ——————————- +<br>| C头| “<em>前缀</em> /包含/ python <em> XY ** abiflags </em> / <em> distname </em>”|</li>
<li>——————- + —————————– ——————————- +</li>
</ul>
<p>实际上并不要求“–prefix”或“–exec-prefix”<br>指向备用Python安装; 如果列出的目录<br>上面还没有，它们是在安装时创建的。</p>
<p>顺便提一下，前缀方案很重要的真正原因很简单<br>标准的Unix安装使用前缀方案，但“ -<br>前缀“和”–exec-prefix“由Python本身提供为”sy​​s.prefix“<br>和“sys.exec_prefix”。因此，你可能会认为你永远不会使用<br>前缀方案，但每次运行“python setup.py install”<br>没有任何其他选项，你正在使用它。</p>
<p>请注意，安装扩展到备用Python安装<br>对这些扩展的构建方式没有影响：特别是<br>随Python一起安装的Python头文件（“Python.h”和朋友）<br>用于运行安装脚本的解释器将用于编译<br>扩展。您有责任确保口译员<br>用来运行以这种方式安装的扩展程序是兼容的<br>用于构建它们的解释器。最好的方法是确保<br>这两个解释器是相同版本的Python（可能<br>不同的版本，或者可能是同一版本的副本）。（当然，<br>如果你的“–prefix”和“–exec-prefix”甚至没有指向<br>备用Python安装，这是无关紧要的。）</p>
<p>备用安装：Windows（前缀方案）</p>
<hr>
<p>Windows没有用户主目录的概念，因为<br>Windows下的标准Python安装比在Unix下简单，<br>传统上使用“–prefix”选项进行安装<br>Windows上不同位置的其他软件包。</p>
<p>   python setup.py install –prefix =“\ Temp \ Python”</p>
<p>将模块安装到当前的“\ Temp \ Python”目录中<br>驾驶。</p>
<p>安装基础由“–prefix”选项定义; “ -<br>Windows下不支持exec-prefix“选项，这意味着<br>纯Python模块和扩展模块安装在同一个中<br>地点。文件安装如下：</p>
<ul>
<li>—————– + ——————————- —————————– +<br>| 文件类型| 安装目录|</li>
<li>================= + =============================== ============================= +<br>| 模块| “<em>前缀</em> \ Lib \ site-packages”|</li>
<li>—————– + ——————————- —————————– +<br>| 脚本| “<em>前缀</em> \脚本”|</li>
<li>—————– + ——————————- —————————– +<br>| 数据| “<em>前缀</em>”|</li>
<li>—————– + ——————————- —————————– +<br>| C头| “<em>前缀</em> \包含{distname}”|</li>
<li>—————– + ——————————- —————————– +</li>
</ul>
<h1 id="自定义安装"><a href="#自定义安装" class="headerlink" title="自定义安装"></a>自定义安装</h1><p>有时，部分中描述了备用安装方案<br>替代安装只是不做你想要的。你可能想要<br>调整只有一个或两个目录，同时保持所有内容<br>相同的基目录，或者您可能想要完全重新定义<br>安装方案。在任何一种情况下，您都在创建<em>自定义<br>安装方案</em>。</p>
<p>要创建自定义安装方案，请从其中一个开始<br>备用方案并覆盖某些安装目录<br>用于各种类型的文件，使用以下选项：</p>
<ul>
<li>———————— + ———————— -  +<br>| 文件类型| 覆盖选项|</li>
<li>======================== + ======================== = +<br>| Python模块| “–install-purelib”|</li>
<li>———————— + ———————— -  +<br>| 扩展模块| “–install-platlib”|</li>
<li>———————— + ———————— -  +<br>| 所有模块| “–install-lib”|</li>
<li>———————— + ———————— -  +<br>| 脚本| “–install-scripts”|</li>
<li>———————— + ———————— -  +<br>| 数据| “–install-data”|</li>
<li>———————— + ———————— -  +<br>| C头| “–install-headers”|</li>
<li>———————— + ———————— -  +</li>
</ul>
<p>这些覆盖选项可以是相对，绝对或显式<br>根据其中一个安装基目录定义。（那里<br>是两个安装基目录，它们通常是相同的<br>—它们只有在您使用Unix“前缀方案”并提供时才会有所不同<br>不同的“–prefix”和“–exec-prefix”选项; 使用“–install-<br>lib“将覆盖为”–install-purelib“计算或给出的值<br>和“–install-platlib”，建议用于没有的方案<br>在Python和扩展模块之间做出改变。）</p>
<p>例如，假设您正在将模块分发安装到您的家中<br>Unix下的目录—但你想让脚本进入“〜/ scripts”<br>而不是“〜/ bin”。正如您所料，您可以覆盖它<br>目录下带有“–install-scripts”选项; 在这种情况下，它使<br>最有意义的是提供相对路径，这将被解释<br>相对于安装基目录（您的主目录，在<br>这个案例）：</p>
<p>   python setup.py install –home =〜–install-scripts = scripts</p>
<p>另一个Unix示例：假设您的Python安装已构建完成<br>安装前缀为“/ usr / local / python”，所以根据标准<br>安装脚本将在“/ usr / local / python / bin”中结束。如果你<br>想要他们在“/ usr / local / bin”中，你会提供这个绝对的<br>“–install-scripts”选项的目录：</p>
<p>   python setup.py install –install-scripts = / usr / local / bin</p>
<p>（这使用“前缀方案”执行安装，其中<br>前缀是你的Python解释器安装的任何东西—<br>“/ usr / local / python”在这种情况下。）</p>
<p>如果您在Windows上维护Python，则可能需要第三方模块<br>住在“<em> prefix </em>”的子目录中，而不是右边的<br>“<em> prefix </em>”本身。这几乎和自定义脚本一样简单<br>安装目录—你只需要记住有两个<br>需要担心的模块类型，Python和扩展模块，其中<br>可以方便地通过一个选项控制：</p>
<p>   python setup.py install –install-lib = Site</p>
<p>指定的安装目录相对于“<em> prefix </em>”。的<br>当然，您还必须确保此目录在Python中<br>模块搜索路径，例如在站点中放置“.pth”文件<br>目录（参见“网站”）。请参阅修改Python的搜索路径部分<br>了解如何修改Python的搜索路径。</p>
<p>如果要定义整个安装方案，则必须这样做<br>提供所有安装目录选项。推荐的方式<br>这样做是为了提供相对路径; 例如，如果你想<br>在家中的“python”下维护所有与Python模块相关的文件<br>目录，并且您希望每个平台都有一个单独的目录<br>您使用自己的主目录，您可以定义以下内容<br>安装方案：</p>
<p>   python setup.py install –home =〜\<br>                           –install-purelib = python / lib \<br>                           –install-platlib = python / lib。$ PLAT \<br>                           –install-脚本=蟒/脚本<br>                           –install数据=蟒/数据</p>
<p>或者，等效地，</p>
<p>   python setup.py install –home =〜/ python \<br>                           –install-purelib = lib \<br>                           –install-platlib =’lib。$ PLAT’\<br>                           –install的脚本的脚本=<br>                           –install数据=数据</p>
<p>“$ PLAT”不是（必然）环境变量—它将是<br>由Distutils扩展，因为它解析您的命令行选项，只是<br>就像解析配置文件时一样。</p>
<p>显然，每次都指定整个安装方案<br>安装新的模块分发会非常繁琐。因此，你<br>可以将这些选项放入Distutils配置文件中（参见章节<br>Distutils配置文件）：</p>
<p>   [安装]<br>   安装基础= $ HOME<br>   安装-purelib =蟒/ lib中<br>   安装-platlib =蟒蛇/ lib目录下。$ PLAT<br>   安装的脚本=蟒/脚本<br>   安装数据=蟒/数据</p>
<p>或者，等效地，</p>
<p>   [安装]<br>   安装基= $ HOME /蟒<br>   安装-purelib = LIB<br>   安装-platlib = lib目录下。$ PLAT<br>   安装的脚本=脚本<br>   安装数据=数据</p>
<p>请注意，如果您提供不同的，这两个*不等同<br>运行安装脚本时的安装基目录。对于<br>例，</p>
<p>   python setup.py install –install-base = / tmp</p>
<p>将在第一种情况下将纯模块安装到“/ tmp / python / lib”，并且<br>在第二种情况下为“/ tmp / lib”。（对于第二种情况，你可能<br>想要提供“/ tmp / python”的安装基础。）</p>
<p>您可能已经注意到样本中使用了“$ HOME”和“$ PLAT”<br>配置文件输入。这些是Distutils配置<br>变量，与环境变量非常相似。<br>实际上，您可以在配置文件中使用环境变量<br>具有这种概念的平台，但另外还有Distutils<br>定义一些可能不在您的环境中的额外变量，例如<br>作为“$ PLAT”。（当然，在没有环境的系统上<br>变量，如Mac OS 9，由…提供的配置变量<br>Distutils是你唯一可以使用的。）参见Distutils部分<br>配置文件详细信息。</p>
<p>注意：激活虚拟环境时，任何选项都可以<br>  更改安装路径将被忽略所有distutils<br>  配置文件，以防止无意中安装项目<br>  在虚拟环境之外。</p>
<h2 id="修改Python的搜索路径"><a href="#修改Python的搜索路径" class="headerlink" title="修改Python的搜索路径"></a>修改Python的搜索路径</h2><p>当Python解释器执行“import”语句时，它<br>在搜索中搜索Python代码和扩展模块<br>路径。路径的默认值配置到Python中<br>构建解释器时的二进制文件。您可以通过确定路径<br>导入“sys”模块并打印“sys.path”的值。</p>
<p>   $ python<br>   Python 2.2（＃11，2002年10月3日，13：31：27）<br>   Linux2上的[GCC 2.96 20000731（Red Hat Linux 7.3 2.96-112）]<br>   输入“帮助”，“版权”，“信用”或“许可”以获取更多信息。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import sys<br>sys.path<br>   [‘’，’/ usr / local / lib / python2.3’，’/ usr / local / lib / python2.3 / plat-linux2’，<br>    ‘/usr/local/lib/python2.3/lib-tk’,’/usr/local/lib/python2.3/lib-dynload’，<br>    ‘/usr/local/lib/python2.3/site-packages’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>“sys.path”中的空字符串表示当前工作<br>目录。</p>
<p>本地安装包的预期约定是放置它们<br>在“<em> … </em> / site-packages /”目录中，但您可能想要安装<br>Python模块进入一些任意目录。例如，您的网站<br>可能有一个保持所有软件与网络相关的约定<br>“/ www”下的服务器。然后可以加入附加Python模块<br>“/ www / python”，并且为了导入它们，这个目录必须是<br>添加到“sys.path”。有几种不同的方法可以添加<br>目录。</p>
<p>最方便的方法是将路径配置文件添加到<br>已经在Python的路径上的目录，通常是“… / site-<br>packages /“目录。路径配置文件的扩展名为<br>“.pth”，每行必须包含一个将被追加的路径<br>到“sys.path”。（因为新路径被附加到“sys.path”，<br>添加目录中的模块不会覆盖标准模块。<br>这意味着您无法使用此机制来安装固定版本<br>标准模块。）</p>
<p>路径可以是绝对的或相对的，在这种情况下它们是相对的<br>包含“.pth”文件的目录。请参阅文档<br>“网站”模块了解更多信息。</p>
<p>一种稍微不方便的方法是编辑“site.py”文件<br>Python的标准库，并修改“sys.path”。“site.py”是<br>除非执行Python解释器时自动导入<br>提供“-S”开关以抑制此行为。所以你可以<br>只需编辑“site.py”并为其添加两行：</p>
<p>   导入系统<br>   sys.path.append（ ‘/ WWW /蟒/‘）</p>
<p>但是，如果你重新安装相同的主要版本的Python（也许<br>当从2.2升级到2.2.2时，例如）“site.py”将是<br>被股票版本覆盖。你必须记住它是<br>在安装之前修改并保存副本。</p>
<p>有两个环境变量可以修改“sys.path”。<br>“PYTHONHOME”为Python的前缀设置备用值<br>安装。例如，如果“PYTHONHOME”设置为“/ www / python”，<br>搜索路径将设置为“[‘’，’/ www / python / lib / pythonX.Y /‘，<br>‘/www/python/lib/pythonX.Y/plat-linux2’，…]“。</p>
<p>“PYTHONPATH”变量可以设置为将要的路径列表<br>添加到“sys.path”的开头。例如，如果“PYTHONPATH”是<br>设置为“/ www / python：/ opt / py”，搜索路径将以<br>“[‘/ www / python’，’/ opt / py’]”。（请注意，目录必须存在于<br>要添加到“sys.path”; “site”模块删除了那些路径<br>不存在。）</p>
<p>最后，“sys.path”只是一个常规的Python列表，所以任何Python<br>应用程序可以通过添加或删除条目来修改它。</p>
<h1 id="Distutils配置文件"><a href="#Distutils配置文件" class="headerlink" title="Distutils配置文件"></a>Distutils配置文件</h1><p>如上所述，您可以使用Distutils配置文件<br>记录任何Distutils选项的个人或网站偏好。那<br>是的，任何命令的任何选项都可以存储在两个或三个中的一个中<br>（取决于您的平台）配置文件，这将是<br>在解析命令行之前咨询。这意味着<br>配置文件将覆盖默认值和命令行<br>将依次覆盖配置文件。此外，如果多个<br>配置文件适用，覆盖“早期”文件中的值<br>通过“以后”文件。</p>
<h2 id="配置文件的位置和名称"><a href="#配置文件的位置和名称" class="headerlink" title="配置文件的位置和名称"></a>配置文件的位置和名称</h2><p>配置文件的名称和位置略有不同<br>跨平台。在Unix和Mac OS X上，有三个配置文件<br>（按照处理顺序）是：</p>
<ul>
<li>—————- + ——————————– —————————- + ——— +<br>| 文件类型| 位置和文件名| 备注|</li>
<li>===== + ================================ ============================ + ========= +<br>| 系统| “<em> prefix </em> / lib / python <em> ver </em> / distutils / distutils.cfg”| （1）|</li>
<li>—————- + ——————————– —————————- + ——— +<br>| 个人| “$ HOME / .pydistutils.cfg”| （2）|</li>
<li>—————- + ——————————– —————————- + ——— +<br>| 当地的| “setup.cfg”| （3）|</li>
<li>—————- + ——————————– —————————- + ——— +</li>
</ul>
<p>在Windows上，配置文件是：</p>
<ul>
<li>—————- + ——————————– ——————- + ——— +<br>| 文件类型| 位置和文件名| 备注|</li>
<li>===== + ================================ =================== + ========= +<br>| 系统| “<em>前缀</em> \ Lib \ distutils \ distutils.cfg”| （4）|</li>
<li>—————- + ——————————– ——————- + ——— +<br>| 个人| “％HOME％\ pydistutils.cfg”| （5）|</li>
<li>—————- + ——————————– ——————- + ——— +<br>| 当地的| “setup.cfg”| （3）|</li>
<li>—————- + ——————————– ——————- + ——— +</li>
</ul>
<p>在所有平台上，“个人”文件可以暂时禁用<br>传递<em>  -  no-user-cfg </em>选项。</p>
<p>笔记：</p>
<p>1.严格来说，系统范围的配置文件存在<br>   Distutils安装的目录; 在Python 1.6下<br>   后来在Unix上，如图所示。对于Python 1.5.2，<br>   Distutils通常会被安装到<br>   “<em>前缀</em> / lib / python1.5 / site- packages / distutils”，所以系统<br>   配置文件应放在Python 1.5.2下。</p>
<p>2.在Unix上，如果未定义“HOME”环境变量，则<br>   用户的主目录将通过“getpwuid（）”确定<br>   功能来自标准的“pwd”模块。这是由<br>   “Distutils使用的”os.path.expanduser（）“函数。</p>
<p>即，在当前目录中（通常是。的位置）<br>   安装脚本）。</p>
<p>4.（另请参阅注释（1）。）在Python 1.6及更高版本中，Python<br>   默认的“安装前缀”是“C：\ Python”，所以系统<br>   配置文件通常是<br>   “C：\ Python的\ LIB \的distutils \ distutils.cfg”。在Python 1.5.2下，<br>   默认前缀是“C：\ Program Files \ Python”和Distutils<br>   不属于标准库—所以系统配置<br>   文件将是“C：\ Program Files \ Python \ distutils \ distutils.cfg”in<br>   Windows下的标准Python 1.5.2安装。</p>
<p>5.在Windows上，如果未定义“HOME”环境变量，<br>   “USERPROFILE”然后“HOMEDRIVE”和“HOMEPATH”将被尝试。这个<br>   由Distutils使用的“os.path.expanduser（）”函数完成。</p>
<h2 id="配置文件的语法"><a href="#配置文件的语法" class="headerlink" title="配置文件的语法"></a>配置文件的语法</h2><p>Distutils配置文件都具有相同的语法。该<br>配置文件分为几个部分。每个都有一个部分<br>Distutils命令，以及全局选项的“全局”部分<br>影响每个命令。每个部分包含每行一个选项，<br>指定为“option = value”。</p>
<p>例如，以下是强制执行的完整配置文件<br>默认情况下默认运行的所有命令：</p>
<p>   [全球]<br>   冗长= 0</p>
<p>如果将其作为系统配置文件安装，则会影响所有<br>由任何用户处理任何Python模块分发<br>现行制度。如果它作为您的个人配置文件安装（打开<br>支持它们的系统），它只会影响模块分布<br>由你处理。如果它被用作a的“setup.cfg”<br>特定的模块分布，它只影响该分布。</p>
<p>您可以覆盖默认的“构建基础”目录并制作<br><strong> build *</strong>命令总是强制重建所有文件<br>以下：</p>
<p>   [建立]<br>   建基= BLIB<br>   力= 1</p>
<p>它对应于命令行参数</p>
<p>   python setup.py build –build-base = blib –force</p>
<p>除了在命令行上包含<strong> build </strong>命令之外<br>该命令将被运行。在config中包含特定命令<br>文件没有这样的含义; 它只表示命令是<br>运行，配置文件中的选项将适用。（或者如果是其他命令<br>从它运行的派生值，他们将使用中的值<br>配置文件。）</p>
<p>您可以找到使用任何命令的完整选项列表<br>“ -  help”选项，例如：</p>
<p>   python setup.py build –help</p>
<p>你可以使用“ - 找出全局选项的完整列表<br>帮助“没有命令：</p>
<p>   python setup.py –help</p>
<p>另请参阅“分发Python模块”的“参考”部分<br>手册。</p>
<h1 id="构建扩展：提示和技巧"><a href="#构建扩展：提示和技巧" class="headerlink" title="构建扩展：提示和技巧"></a>构建扩展：提示和技巧</h1><p>只要有可能，Distutils会尝试使用配置<br>用于运行的Python解释器提供的信息<br>“setup.py”脚本。例如，相同的编译器和链接器标志<br>用于编译Python也将用于编译扩展。<br>通常这会很好，但在复杂的情况下这可能会<br>不合适。本节讨论如何覆盖通常<br>Distutils的行为。</p>
<h2 id="调整编译器-链接器标志"><a href="#调整编译器-链接器标志" class="headerlink" title="调整编译器/链接器标志"></a>调整编译器/链接器标志</h2><p>有时，编译用C或C ++编写的Python扩展<br>要求按顺序为编译器和链接器指定自定义标志<br>使用特定的库或生成特殊类型的目标代码。<br>如果未对您的扩展程序进行测试，则尤其如此<br>平台，或者如果您正在尝试交叉编译Python。</p>
<p>在最一般的情况下，扩展作者可能已经预见到了<br>编译扩展将是复杂的，并提供了一个<br>“设置”文件供您编辑。这可能只有在<br>模块分发包含许多单独的扩展模块，或者如果<br>他们经常需要精心设置的编译器标志才能工作。</p>
<p>解析“Setup”文件（如果存在）以获取列表<br>构建的扩展。“设置”中的每一行都描述了一行<br>模块。行具有以下结构：</p>
<p>   module … [sourcefile …] [cpparg …] [library …]</p>
<p>让我们依次检查每个字段。</p>
<ul>
<li><ul>
<li>module *是要构建的扩展模块的名称<br>应该是一个有效的Python标识符。你不能只是改变它<br>为了重命名模块（对源代码的编辑也将是<br>需要），所以这应该是孤立的。</li>
</ul>
</li>
<li><ul>
<li>sourcefile *是任何可能是源代码文件的东西，<br>至少通过文件名来判断。以“.c”结尾的文件名是<br>假设用C语言编写，文件名以“.C”，“。cc”结尾<br>假设“.c ++”是C ++，文件名以“.m”或“。mm”结尾<br>被假定为目标C.</li>
</ul>
</li>
<li><ul>
<li>cpparg *是C预处理器的参数，并且是任何东西<br>以“-I”，“ -  D”，“ -  U”或“-C”开头。</li>
</ul>
</li>
<li><ul>
<li>library *是以“.a”结尾或以“-l”开头的任何内容<br>“-L”。</li>
</ul>
</li>
</ul>
<p>如果特定平台需要您平台上的特殊库，<br>你可以通过编辑“Setup”文件并运行“python”来添加它<br>setup.py build“。例如，如果该行定义的模块</p>
<p>   foo foomodule.c</p>
<p>必须与平台上的数学库“libm.a”链接<br>在行中添加“-lm”：</p>
<p>   foo foomodule.c -lm</p>
<p>用于编译器或链接器的任意开关都可以<br>提供“-Xcompiler”<em> arg </em>和“-Xlinker”<em> arg </em>选项：</p>
<p>   foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm</p>
<p>“-Xcompiler”和“-Xlinker”之后的下一个选项将被附加到<br>正确的命令行，所以在上面的例子中编译器将是<br>传递了“-o32”选项，链接器将被传递“-shared”。如果<br>编译器选项需要一个参数，你必须提供多个<br>“-Xcompiler”选项; 例如，将“-x c ++”传递给“Setup”文件<br>必须包含“-Xcompiler -x -Xcompiler c ++”。</p>
<p>也可以通过设置“CFLAGS”来提供编译器标志<br>环境变量。如果设置，将添加“CFLAGS”的内容<br>到“安装”文件中指定的编译器标志。</p>
<h2 id="在Windows上使用非Microsoft编译器"><a href="#在Windows上使用非Microsoft编译器" class="headerlink" title="在Windows上使用非Microsoft编译器"></a>在Windows上使用非Microsoft编译器</h2><p>Borland / CodeGear C ++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">本小节描述了使用Distutils的必要步骤</div><div class="line">Borland C ++编译器版本5.5。首先你必须知道</div><div class="line">Borland的目标文件格式（OMF）与使用的格式不同</div><div class="line">通过Python版本，您可以从Python或ActiveState下载</div><div class="line">网站。（Python是使用Microsoft Visual C ++构建的，它使用COFF</div><div class="line">作为目标文件格式。）因此你必须转换</div><div class="line">Python的库“python25.lib”进入Borland格式。你可以做</div><div class="line">这如下：</div><div class="line"></div><div class="line">   coff2omf python25.lib python25_bcpp.lib</div><div class="line"></div><div class="line">“coff2omf”程序附带Borland编译器。文件</div><div class="line">“python25.lib”位于Python安装的“Libs”目录中。</div><div class="line">如果您的扩展使用其他库（zlib，...），则必须进行转换</div><div class="line">他们也是。</div><div class="line"></div><div class="line">转换后的文件必须与...保持相同的目录</div><div class="line">普通图书馆。</div><div class="line"></div><div class="line">Distutils如何通过更改来管理这些库的使用</div><div class="line">名字呢？如果扩展需要库（例如“foo”）Distutils检查</div><div class="line">首先，如果它找到一个带有后缀“_bcpp”的库（例如“foo_bcpp.lib”）</div><div class="line">然后使用此库。在它没有找到这样的情况下</div><div class="line">特殊库它使用默认名称（“foo.lib”。）[1]</div><div class="line"></div><div class="line">要让Distutils使用Borland C ++编译你的扩展，你现在拥有</div><div class="line">输入：</div><div class="line"></div><div class="line">   python setup.py build --compiler = bcpp</div><div class="line"></div><div class="line">如果你想使用Borland C ++编译器作为默认值，你可以</div><div class="line">在您的个人或系统范围的配置文件中指定</div><div class="line">Distutils（参见Distutils配置文件一节。）</div><div class="line"></div><div class="line">也可以看看：</div><div class="line"></div><div class="line">  C ++ Builder编译器</div><div class="line">     有关Borland免费C ++编译器的信息，包括</div><div class="line">     链接到下载页面。</div><div class="line"></div><div class="line">  使用Borland的免费编译器创建Python扩展</div><div class="line">     描述如何使用Borland的免费命令行C ++的文档</div><div class="line">     编译器来构建Python。</div><div class="line"></div><div class="line"></div><div class="line">GNU C / Cygwin / MinGW</div><div class="line">~~</div></pre></td></tr></table></figure></p>
<p>本节介绍使用Distutils的必要步骤<br>他们的Cygwin和MinGW发行版中的GNU C / C ++编译器。[2]对于<br>用Cygwin构建的Python解释器，一切都应该有效<br>没有以下任何步骤。</p>
<p>并非所有扩展都可以使用MinGW或Cygwin构建，但很多都可以。<br>最可能不起作用的扩展是那些使用C ++或依赖的扩展<br>Microsoft Visual C扩展。</p>
<p>要让Distutils使用Cygwin编译您的扩展，您必须输入：</p>
<p>   python setup.py build –compiler = cygwin</p>
<p>对于Cygwin in-cygwin模式[3]或MinGW类型：</p>
<p>   python setup.py build –compiler = mingw32</p>
<p>如果您想将这些选项/编译器中的任何一个用作默认值，那么您就是<br>应考虑在您的个人或系统范围内撰写<br>Distutils的配置文件（请参阅Distutils配置部分<br>文件）。</p>
<p>旧版本的Python和MinGW<br>“”“”“”“”“”“”“”“”“”“”“”“”“”“”“”“”“”</p>
<p>以下说明仅适用于您使用的版本<br>Python低于2.4.1，MinGW低于3.0.0（带有<br>的binutils-2.13.90-20030111-1）。</p>
<p>这些编译器需要一些特殊的库。这项任务更多<br>比Borland的C ++复杂，因为没有程序可以转换<br>图书馆。首先，你必须创建一个符号列表<br>Python DLL导出。（你可以在htt。找到一个很好的程序来完成这项任务<br>PS：//sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/）。</p>
<p>   pexports python25.dll&gt; python25.def</p>
<p>安装“python25.dll”的位置取决于<br>安装选项以及Windows的版本和语言。在一个<br>“只为我”安装，它将出现在根<br>安装目录。在共享安装中，它将被定位<br>在系统目录中。</p>
<p>然后，您可以从这些信息创建gcc的导入库。</p>
<p>   / cygwin / bin / dlltool –dllname python25.dll –def python25.def –output-lib libpython25.a</p>
<p>生成的库必须放在同一目录中<br>“python25.lib”。（应该是Python下的“libs”目录<br>安装目录。）</p>
<p>如果您的扩展使用其他库（zlib，…），则可能需要<br>转换它们。转换后的文件必须位于同一个文件中<br>像普通库那样的目录。</p>
<p>也可以看看：</p>
<p>  使用MinGW在MS Windows平台上构建Python模块<br>     有关为MinGW构建所需库的信息<br>     环境。</p>
<ul>
<li>[脚注]  - </li>
</ul>
<p>[1]这也意味着您可以替换所有现有的COFF库<br>    使用同名的OMF库。</p>
<p>[2]检查<a href="https://www.sourceware.org/cygwin/和" target="_blank" rel="external">https://www.sourceware.org/cygwin/和</a><br>    <a href="http://www.mingw.org/了解更多信息" target="_blank" rel="external">http://www.mingw.org/了解更多信息</a></p>
<p>[3]然后你没有可用的POSIX仿真，但你也没有<br>    需要“cygwin1.dll”。</p>
<p>安装Python模块</p>
<hr>
<p>电子邮件：<br>   distutils-sig@python.org</p>
<p>作为一个流行的开源开发项目，Python有一个活跃的<br>支持贡献者社区和用户也做出贡献<br>可供其他Python开发人员在open下使用的软件<br>源许可条款。</p>
<p>这允许Python用户有效地共享和协作，<br>受益于其他人已经创造的共同解决方案<br>（有时甚至是罕见的！）问题，以及潜在的问题<br>为公共池提供自己的解决方案。</p>
<p>本指南涵盖了该过程的安装部分。有关指南<br>创建和共享您自己的Python项目，请参阅<br>分发指南。</p>
<p>注意：对于公司和其他机构用户，请注意这一点<br>  许多组织都有自己的使用和策略<br>  为开源软件做贡献。请采取这样的政策<br>  使用分发和安装工具时的帐户<br>  随Python提供。</p>
<h1 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h1><p>*“pip”是首选的安装程序。从Python开始<br>  3.4，默认包含在Python二进制安装程序中。</p>
<ul>
<li><em>虚拟环境</em>是一个半隔离的Python环境<br>允许安装包以供特定应用程序使用，<br>而不是系统安装。</li>
</ul>
<p>*“venv”是创建虚拟环境的标准工具<br>  自Python 3.3以来一直是Python的一部分。从Python 3.4开始，<br>  它默认在所有创建的虚拟中安装“pip”<br>  环境。</p>
<p>*“virtualenv”是第三方替代品（和前身）<br>  “VENV”。它允许在版本上使用虚拟环境<br>  3.4之前的Python，要么根本不提供“venv”，要么<br>  无法自动将“pip”安装到已创建的<br>  环境。</p>
<ul>
<li><p>Python Packaging Index是一个开源的公共存储库<br>许可包可供其他Python用户使用。</p>
</li>
<li><p>Python Packaging Authority是一组开发人员和<br>负责维护和演变的文档作者<br>标准打包工具以及相关的元数据和文件<br>格式标准。他们维护着各种工具，文档，<br>并在GitHub和BitBucket上发布跟踪器。</p>
</li>
</ul>
<p>*“distutils”是最初的构建和分发系统<br>  在1998年添加到Python标准库。直接使用<br>  “distutils”正在逐步淘汰，它仍然奠定了基础<br>  目前的包装和配送基础设施，而不是<br>  只是标准库的一部分，但它的名字仍然存在<br>  其他方式（例如用于协调的邮件列表的名称<br>  Python包装标准开发）。</p>
<p>从版本3.6开始不推荐使用：“pyvenv”是推荐的工具<br>为Python 3.3和3.4创建虚拟环境，并且是<br>在Python 3.6中弃用。</p>
<p>版本3.5中已更改：现在建议使用“venv”<br>创建虚拟环境。</p>
<p>另请参阅：Python包装用户指南：创建和使用虚拟<br>  环境</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>标准的包装工具都是为了使用而设计的<br>命令行。</p>
<p>以下命令将安装最新版本的模块和<br>它与Python包装索引的依赖关系：</p>
<p>   python -m pip安装SomePackage</p>
<p>注意：对于POSIX用户（包括Mac OS X和Linux用户），<br>  本指南中的示例假定使用<em>虚拟环境</em> .For<br>  Windows用户，本指南中的示例假定选项为<br>  调整系统时选择PATH环境变量<br>  安装Python。</p>
<p>也可以直接指定精确或最小版本<br>命令行。使用比较器运算符时，例如“&gt;”，“&lt;”或<br>一些其他特殊字符，由shell解释，<br>包名称和版本应该用双引号括起来：</p>
<p>   python -m pip install SomePackage == 1.0.4＃specific version<br>   python -m pip install“SomePackage&gt; = 1.0.4”＃minimum version</p>
<p>通常，如果已经安装了合适的模块，则尝试<br>再次安装将无效。必须升级现有模块<br>明确要求：</p>
<p>   python -m pip install –upgrade SomePackage</p>
<p>有关“点子”及其功能的更多信息和资源<br>可以在Python Packaging用户指南中找到。</p>
<p>通过“venv”模块创建虚拟环境。<br>将软件包安装到活动的虚拟环境中使用<br>上面显示的命令。</p>
<p>另请参阅：Python包装用户指南：安装Python<br>  分发包</p>
<h1 id="我如何能-…？"><a href="#我如何能-…？" class="headerlink" title="我如何能 …？"></a>我如何能 …？</h1><p>这些是一些常见任务的快速答案或链接。</p>
<p>…在Python 3.4之前的Python版本中安装“pip”？</p>
<hr>
<p>Python只开始用Python 3.4捆绑“pip”。早点<br>版本，“pip”需要“引导”，如Python中所述<br>包装用户指南。</p>
<p>另请参阅：Python打包用户指南：安装要求<br>  包</p>
<h2 id="…仅为当前用户安装软件包？"><a href="#…仅为当前用户安装软件包？" class="headerlink" title="…仅为当前用户安装软件包？"></a>…仅为当前用户安装软件包？</h2><p>将“–user”选项传递给“python -m pip install”将安装一个<br>包只是为当前用户，而不是为所有用户<br>系统。</p>
<h2 id="…安装科学的Python包？"><a href="#…安装科学的Python包？" class="headerlink" title="…安装科学的Python包？"></a>…安装科学的Python包？</h2><p>许多科学的Python包都有复杂的二进制文件<br>依赖项，目前使用“pip”不易安装<br>直。此时，用户通常会更容易<br>通过其他方式安装这些软件包而不是尝试<br>用“pip”安装它们。</p>
<p>另请参阅：Python包装用户指南：安装Scientific<br>  包</p>
<p>…与多个版本的Python并行安装？</p>
<hr>
<p>在Linux，Mac OS X和其他POSIX系统上，使用版本化的Python<br>命令与“-m”开关组合运行相应的<br>“点”的副本：</p>
<p>   python2 -m pip install SomePackage #default Python 2<br>   python2.7 -m pip install SomePackage＃具体是Python 2.7<br>   python3 -m pip install SomePackage＃default Python 3<br>   python3.4 -m pip install SomePackage＃具体是Python 3.4</p>
<p>也可以使用适当版本化的“pip”命令。</p>
<p>在Windows上，将“py”Python启动器与“-m”结合使用<br>开关：</p>
<p>   py -2 -m pip install SomePackage #default Python 2<br>   py -2.7 -m pip install SomePackage＃具体是Python 2.7<br>   py -3 -m pip install SomePackage #default Python 3<br>   py -3.4 -m pip install SomePackage＃具体是Python 3.4</p>
<h1 id="常见的安装问题"><a href="#常见的安装问题" class="headerlink" title="常见的安装问题"></a>常见的安装问题</h1><h2 id="在Linux上安装到Python系统中"><a href="#在Linux上安装到Python系统中" class="headerlink" title="在Linux上安装到Python系统中"></a>在Linux上安装到Python系统中</h2><p>在Linux系统上，通常会包含Python安装<br>部分发行。安装到此Python安装中<br>需要root访问系统，并可能会干扰<br>系统包管理器和其他组件的操作<br>系统如果使用“pip”意外升级组件。</p>
<p>在这样的系统上，通常最好使用虚拟环境或<br>使用“pip”安装软件包时的每用户安装。</p>
<h2 id="Pip未安装"><a href="#Pip未安装" class="headerlink" title="Pip未安装"></a>Pip未安装</h2><p>默认情况下，“pip”可能未安装。一<br>可能的解决方法是</p>
<p>   python -m ensurepip –default-pip</p>
<p>还有其他资源用于安装pip。</p>
<h2 id="安装二进制扩展"><a href="#安装二进制扩展" class="headerlink" title="安装二进制扩展"></a>安装二进制扩展</h2><p>Python通常严重依赖基于源的分发<br>期望最终用户从源代码编译扩展模块<br>部分安装过程。</p>
<p>随着对二进制“轮”格式的支持的引入，和<br>能够为至少Windows和Mac OS X发布轮子<br>通过Python Packaging Index，预计会出现这个问题<br>随着时间的推移逐渐减少，因为用户可以更经常地安装<br>构建扩展而不是自己构建它们。</p>
<p>安装科学软件的一些解决方案不是<br>但是作为预先构建的“轮”文件可用也可以帮助获得<br>其他二进制扩展，无需在本地构建它们。</p>
<p>另请参阅：Python打包用户指南：二进制扩展<br>版权</p>
<hr>
<p>Python和这个文档是：</p>
<p>版权所有©2001-2019 Python软件基金会。版权所有。</p>
<p>版权所有©2000 BeOpen.com。版权所有。</p>
<p>版权所有©1995-2000国家研究计划公司。<br>版权所有。</p>
<p>版权所有©1991-1995 Stichting Mathematisch Centrum。所有权利<br>保留。</p>
<p>================================================== ====================</p>
<p>有关完整许可和权限，请参阅历史记录和许可<br>信息。</p>
<p>##灵气博客翻译</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://python1.cn/2019/01/29/安装Python模块/" data-id="cjrhcaghq00012o8lrddowzxo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/01/29/GitHub博客搭建/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">GitHub如何搭建一个静态博客</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/29/安装Python模块/">安装Python模块(官网翻译)</a>
          </li>
        
          <li>
            <a href="/2019/01/29/GitHub博客搭建/">GitHub如何搭建一个静态博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 灵气博客<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>